using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Net.Http;
using System.Net.Http.Headers;
using System.Text;
using System.Text.Json;
using System.Threading;
using System.Threading.Tasks;
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using YouTubeDubber.Core.Interfaces;
using YouTubeDubber.Core.Models;

namespace YouTubeDubber.Core.Services
{    /// <summary>
    /// Translation service implementation using Azure Translator
    /// </summary>
    public class AzureTranslationService : ITranslationService
    {
        private readonly TranslationOptions _defaultOptions;
        private readonly HttpClient _httpClient;
        
        /// <summary>
        /// Initializes a new instance of the Azure Translation Service
        /// </summary>
        /// <param name="defaultOptions">Default translation options</param>
        public AzureTranslationService(TranslationOptions? defaultOptions = null)
        {
            _defaultOptions = defaultOptions ?? new TranslationOptions();
            _httpClient = new HttpClient();
            _httpClient.DefaultRequestHeaders.Add("Ocp-Apim-Subscription-Key", _defaultOptions.ApiKey);
            _httpClient.DefaultRequestHeaders.Add("Ocp-Apim-Subscription-Region", _defaultOptions.Region);
            _httpClient.DefaultRequestHeaders.Accept.Add(new MediaTypeWithQualityHeaderValue("application/json"));
        }
          /// <summary>
        /// Translates a single text string using Azure Translator
        /// </summary>
        public async Task<TranslationResult> TranslateTextAsync(
            string text,
            TranslationOptions? options = null,
            CancellationToken cancellationToken = default)
        {
            if (string.IsNullOrEmpty(text))
            {
                throw new ArgumentException("Text to translate cannot be empty", nameof(text));
            }
            
            // Use provided options or fall back to default options
            options ??= _defaultOptions;
            
            // Validate API credentials
            if (string.IsNullOrEmpty(options.ApiKey) || string.IsNullOrEmpty(options.Region))
            {
                throw new ArgumentException("Azure Translator API key and region must be provided");
            }
            
            try
            {                // Create the Azure Translator client
                var client = CreateTranslatorClient(options);
                
                // Setup translation request
                var inputs = new List<string> { text };
                
                // Setup translation target
                var targetLanguage = options.TargetLanguage;
                
                // Translate the text
                var response = await client.TranslateAsync(
                    inputs, 
                    targetLanguage, 
                    options.SourceLanguage, 
                    cancellationToken);
                
                // Extract the translated text from the response
                var translations = response.Value;
                
                if (translations.Count == 0 || !translations[0].Translations.Any())
                {
                    throw new InvalidOperationException("No translation result was returned");
                }
                
                // Create and return the translation result
                return new TranslationResult
                {
                    SourceText = text,
                    TranslatedText = translations[0].Translations[0].Text,
                    SourceLanguage = options.SourceLanguage,
                    TargetLanguage = options.TargetLanguage,
                    TranslationTime = DateTime.Now
                };
            }
            catch (Exception ex)
            {
                throw new Exception($"Translation failed: {ex.Message}", ex);
            }
        }
          /// <summary>
        /// Translates multiple text strings in batch using Azure Translator
        /// </summary>
        public async Task<IList<TranslationResult>> TranslateTextsAsync(
            IList<string> texts,
            TranslationOptions? options = null,
            CancellationToken cancellationToken = default)
        {
            if (texts == null || texts.Count == 0)
            {
                throw new ArgumentException("Texts to translate cannot be empty", nameof(texts));
            }
            
            // Use provided options or fall back to default options
            options ??= _defaultOptions;
            
            // Validate API credentials
            if (string.IsNullOrEmpty(options.ApiKey) || string.IsNullOrEmpty(options.Region))
            {
                throw new ArgumentException("Azure Translator API key and region must be provided");
            }
            
            try
            {
                // Create the Azure Translator client
                var client = CreateTranslatorClient(options);
                
                // Translate the texts in batches (Azure supports up to 100 items per batch)
                const int batchSize = 100;
                var results = new List<TranslationResult>();
                
                for (int i = 0; i < texts.Count; i += batchSize)
                {
                    // Get the next batch
                    var batch = texts.Skip(i).Take(batchSize).ToList();
                    
                    // Prepare batch content
                    var batchContents = batch.Select(text => new TranslateContent(text)).ToList();
                    
                    // Translate the batch
                    var response = await client.TranslateAsync(
                        batchContents, 
                        options.TargetLanguage, 
                        options.SourceLanguage,
                        cancellationToken);
                    
                    var translations = response.Value;
                    
                    // Process each translation in the batch
                    for (int j = 0; j < batch.Count && j < translations.Count; j++)
                    {
                        var sourceText = batch[j];
                        var translation = translations[j];
                        
                        if (translation.Translations.Any())
                        {
                            // Create and add the translation result
                            results.Add(new TranslationResult
                            {
                                SourceText = sourceText,
                                TranslatedText = translation.Translations[0].Text,
                                SourceLanguage = options.SourceLanguage,
                                TargetLanguage = options.TargetLanguage,
                                TranslationTime = DateTime.Now
                            });
                        }
                    }
                }
                
                return results;
            }
            catch (Exception ex)
            {
                throw new Exception($"Batch translation failed: {ex.Message}", ex);
            }
        }
        
        /// <summary>
        /// Translates a transcription result, preserving timing information
        /// </summary>
        public async Task<TranslationResult> TranslateTranscriptionAsync(
            TranscriptionResult transcriptionResult,
            TranslationOptions? options = null,
            IProgress<double>? progressCallback = null,
            CancellationToken cancellationToken = default)
        {
            if (transcriptionResult == null || transcriptionResult.Segments.Count == 0)
            {
                throw new ArgumentException("Transcription result is empty or null", nameof(transcriptionResult));
            }
            
            // Use provided options or fall back to default options
            options ??= _defaultOptions;
            
            try
            {
                // Extract all segments for batch translation
                var segmentTexts = transcriptionResult.Segments.Select(s => s.Text).ToList();
                
                // Initialize progress tracking
                int totalSegments = segmentTexts.Count;
                int processedSegments = 0;
                
                // Translate all segments in batch
                var translatedTexts = await TranslateTextsAsync(segmentTexts, options, cancellationToken);
                
                // Create translated segments with preserved timing information
                var translatedSegments = new List<TranslatedSegment>();
                
                for (int i = 0; i < transcriptionResult.Segments.Count; i++)
                {
                    var originalSegment = transcriptionResult.Segments[i];
                    var translatedText = translatedTexts[i].TranslatedText;
                    
                    translatedSegments.Add(new TranslatedSegment
                    {
                        SourceText = originalSegment.Text,
                        TranslatedText = translatedText,
                        StartTime = originalSegment.StartTime,
                        EndTime = originalSegment.EndTime,
                        SourceConfidence = originalSegment.Confidence
                    });
                    
                    // Update progress
                    processedSegments++;
                    progressCallback?.Report((double)processedSegments / totalSegments);
                }
                
                // Create and return the translation result
                return new TranslationResult
                {
                    SourceText = transcriptionResult.FullText,
                    TranslatedText = string.Join(" ", translatedSegments.Select(s => s.TranslatedText)),
                    SourceLanguage = options.SourceLanguage,
                    TargetLanguage = options.TargetLanguage,
                    TranslationTime = DateTime.Now,
                    TranslatedSegments = translatedSegments
                };
            }
            catch (Exception ex)
            {
                throw new Exception($"Transcription translation failed: {ex.Message}", ex);
            }
        }
        
        /// <summary>
        /// Validates the Azure Translator API credentials
        /// </summary>
        public async Task<bool> ValidateCredentialsAsync(
            TranslationOptions options,
            CancellationToken cancellationToken = default)
        {
            try
            {
                // Create client with the credentials
                var client = CreateTranslatorClient(options);
                  // Try to translate a simple text as a validation test
                var inputs = new List<string> { "Hello" };
                
                var response = await client.TranslateAsync(
                    inputs,
                    options.TargetLanguage,
                    options.SourceLanguage,
                    cancellationToken);
                
                // If we get here without exception, the credentials are valid
                return true;
            }
            catch
            {
                // An exception means invalid credentials or connection issues
                return false;
            }
        }
        
        /// <summary>
        /// Gets available language pairs for translation
        /// </summary>
        public async Task<Dictionary<string, string>> GetAvailableLanguagesAsync(
            TranslationOptions? options = null,
            CancellationToken cancellationToken = default)
        {
            // Use provided options or fall back to default options
            options ??= _defaultOptions;
            
            try
            {
                // Create the Azure Translator client
                var client = CreateTranslatorClient(options);
                  // Get available languages
                var response = await client.GetLanguagesAsync(cancellationToken);
                
                var languages = response.Value;
                
                // Create dictionary of language codes and display names
                var languagesDict = new Dictionary<string, string>();
                
                foreach (var language in languages)
                {
                    // Use English display name or fall back to language code
                    string displayName = language.Value.Name ?? language.Key;
                    languagesDict[language.Key] = displayName;
                }
                
                return languagesDict;
            }
            catch (Exception ex)
            {
                throw new Exception($"Failed to get available languages: {ex.Message}", ex);
            }
        }
        
        /// <summary>
        /// Saves the translation result to a file in the specified format
        /// </summary>
        public async Task<string> SaveTranslationAsync(
            TranslationResult translationResult,
            string outputFilePath,
            string format = "txt")
        {
            if (translationResult == null || string.IsNullOrEmpty(translationResult.TranslatedText))
            {
                throw new ArgumentException("Translation result is empty or null");
            }
            
            string content;
            
            switch (format.ToLower())
            {
                case "txt":
                    content = translationResult.TranslatedText;
                    break;
                    
                case "srt":
                    content = FormatAsSrt(translationResult);
                    break;
                    
                case "json":
                    content = JsonConvert.SerializeObject(translationResult, Newtonsoft.Json.Formatting.Indented);
                    break;
                    
                case "bilingual":
                    content = FormatBilingual(translationResult);
                    break;
                    
                default:
                    throw new ArgumentException($"Unsupported format: {format}");
            }
            
            string directoryPath = Path.GetDirectoryName(outputFilePath) ?? string.Empty;
            if (!string.IsNullOrEmpty(directoryPath) && !Directory.Exists(directoryPath))
            {
                Directory.CreateDirectory(directoryPath);
            }
            
            await File.WriteAllTextAsync(outputFilePath, content);
            return outputFilePath;
        }
        
        #region Private Helper Methods
          /// <summary>
        /// Creates a TextTranslationClient using the specified options
        /// </summary>
        private TextTranslationClient CreateTranslatorClient(TranslationOptions options)
        {
            // Create the client authentication
            var credential = new AzureKeyCredential(options.ApiKey);
              // Create the client with the endpoint
            var endpoint = new Uri($"https://api.cognitive.microsofttranslator.com/");
            
            // Create client options to specify the region
            var clientOptions = new TextTranslationClientOptions();
            clientOptions.AddPolicy(new AddHeadersPolicy(options.Region), HttpPipelinePosition.PerCall);
            
            return new TextTranslationClient(credential, clientOptions);
        }
        
        /// <summary>
        /// Formats the translation result as an SRT subtitle file
        /// </summary>
        private string FormatAsSrt(TranslationResult translationResult)
        {
            if (translationResult.TranslatedSegments == null || translationResult.TranslatedSegments.Count == 0)
            {
                return translationResult.TranslatedText;
            }
            
            var srtBuilder = new StringBuilder();
            
            for (int i = 0; i < translationResult.TranslatedSegments.Count; i++)
            {
                var segment = translationResult.TranslatedSegments[i];
                
                // Add subtitle number
                srtBuilder.AppendLine($"{i + 1}");
                
                // Add timestamp (format: 00:00:00,000 --> 00:00:00,000)
                string startTime = FormatTimeSpan(TimeSpan.FromSeconds(segment.StartTime));
                string endTime = FormatTimeSpan(TimeSpan.FromSeconds(segment.EndTime));
                srtBuilder.AppendLine($"{startTime} --> {endTime}");
                
                // Add text
                srtBuilder.AppendLine(segment.TranslatedText);
                
                // Add blank line between entries
                srtBuilder.AppendLine();
            }
            
            return srtBuilder.ToString();
        }
        
        /// <summary>
        /// Formats the translation result as a bilingual text file with both source and target languages
        /// </summary>
        private string FormatBilingual(TranslationResult translationResult)
        {
            if (translationResult.TranslatedSegments == null || translationResult.TranslatedSegments.Count == 0)
            {
                return $"{translationResult.SourceText}\n\n{translationResult.TranslatedText}";
            }
            
            var bilingualBuilder = new StringBuilder();
            
            bilingualBuilder.AppendLine($"Source Language: {translationResult.SourceLanguage}");
            bilingualBuilder.AppendLine($"Target Language: {translationResult.TargetLanguage}");
            bilingualBuilder.AppendLine($"Translation Time: {translationResult.TranslationTime}");
            bilingualBuilder.AppendLine();
            
            for (int i = 0; i < translationResult.TranslatedSegments.Count; i++)
            {
                var segment = translationResult.TranslatedSegments[i];
                
                bilingualBuilder.AppendLine($"[{TimeSpan.FromSeconds(segment.StartTime):hh\\:mm\\:ss} - {TimeSpan.FromSeconds(segment.EndTime):hh\\:mm\\:ss}]");
                bilingualBuilder.AppendLine($"SOURCE: {segment.SourceText}");
                bilingualBuilder.AppendLine($"TARGET: {segment.TranslatedText}");
                bilingualBuilder.AppendLine();
            }
            
            return bilingualBuilder.ToString();
        }
        
        /// <summary>
        /// Formats a TimeSpan as an SRT timestamp (00:00:00,000)
        /// </summary>
        private string FormatTimeSpan(TimeSpan time)
        {
            return $"{time.Hours:00}:{time.Minutes:00}:{time.Seconds:00},{time.Milliseconds:000}";
        }
        
        /// <summary>
        /// A policy to add Translator API headers
        /// </summary>
        private class AddHeadersPolicy : HttpPipelineSynchronousPolicy
        {
            private readonly string _region;

            public AddHeadersPolicy(string region)
            {
                _region = region;
            }

            public override void OnSendingRequest(HttpMessage message)
            {
                base.OnSendingRequest(message);
                message.Request.Headers.Add("Ocp-Apim-Subscription-Region", _region);
            }
        }

        #endregion
    }
}
